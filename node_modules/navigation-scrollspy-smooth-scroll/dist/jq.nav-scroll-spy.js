'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (root, factory, undefined) {
		if (typeof define === 'function' && define.amd) {
				//AMD
				define(['jquery'], factory);
		} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
				//CommonJS
				var $ = requie('jquery');
				module.exports = factory($);
		} else {
				//都不是，浏览器全局定义
				root.navScrollSpy = factory(root.jQuery);
		}
})(window, function ($) {
		var pluginName = 'jqNavScrollSpy';
		var defaults = {
				navItems: '.nav-item', //导航元素
				scrollContainer: 'html,body', //滚动的容器
				spyItems: '.spy-item', //监视的元素
				easing: 'swing', //动效
				speed: 550 //速度
		};

		var jqNavScrollSpy = function () {
				function jqNavScrollSpy(element, configs) {
						_classCallCheck(this, jqNavScrollSpy);

						this._element = element;
						this.$win = $(window);
						this.defaults = $.extend({}, defaults, configs);
						this.init();
				}
				//初始化


				_createClass(jqNavScrollSpy, [{
						key: 'init',
						value: function init() {
								this.$navItems = $(this.defaults.navItems);
								this.$spyItems = $(this.defaults.spyItems);
								this.$scrollContainer = $(this.defaults.scrollContainer);
								this.fixTop = $(this.$spyItems[0]).offset().top; //修正初始化的时候元素距离顶部的距离不等于滚动的距离的变量，也就是减去第一个元素距离顶部的高度
								this.spyItemsData = this.getSpyItemsData();
								this.spyScroll();
								this.clickSwitch();
						}
						//监听滚动事件

				}, {
						key: 'spyScroll',
						value: function spyScroll() {
								this.$win.on('scroll', this.throttle(this.scrollCallBack, 100, 200));
						}
						//滚动监听的回调函数

				}, {
						key: 'scrollCallBack',
						value: function scrollCallBack() {
								var spyIndex = this.getVisibleElIndex();
								this.changeNav(this.$navItems[spyIndex]);
						}
						//存储监视滚动元素的中心位置数组

				}, {
						key: 'getSpyItemsData',
						value: function getSpyItemsData() {
								var _this2 = this;

								var spyItemsData = [];
								this.$spyItems.each(function (index) {
										spyItemsData[index] = (_this2.getOffsetTop(index) + _this2.getOffsetTop(index) + $(_this2.$spyItems[index]).height()) / 2;
								});
								return spyItemsData;
						}
						//获得当前滚动到视图区的元素的索引

				}, {
						key: 'getVisibleElIndex',
						value: function getVisibleElIndex() {
								var _this3 = this;

								var spyIndex = void 0;
								var scrollTop = parseInt(this.$win.scrollTop());
								$.each(this.spyItemsData, function (index) {
										if (_this3.spyItemsData[0] >= scrollTop) {
												spyIndex = 0;
												return true;
										} else if (_this3.spyItemsData[index] <= scrollTop && scrollTop <= _this3.spyItemsData[index + 1]) {
												spyIndex = index + 1;
												return true;
										}
								});
								return spyIndex;
						}
						//节流函数

				}, {
						key: 'throttle',
						value: function throttle(func, wait, mustRun) {
								var timeout = void 0,
								    context = this,
								    startTime = new Date();
								return function () {
										var args = arguments,
										    curTime = new Date();
										clearTimeout(timeout);
										// 如果达到了规定的触发时间间隔，触发 handler
										if (curTime - startTime >= mustRun) {
												func.apply(context, args);
												startTime = curTime;
												// 没达到触发间隔，重新设定定时器
										} else {
												timeout = setTimeout(func.bind(context), wait);
										}
								};
						}
						//点击切换

				}, {
						key: 'clickSwitch',
						value: function clickSwitch() {
								var _this = this;
								this.$navItems.on("click", function () {
										_this.changeNav(this);
										var navIndex = $(this).index();
										_this.$win.off("scroll");
										_this.scrollIntoView(navIndex);
								});
						}
						//改变导航active

				}, {
						key: 'changeNav',
						value: function changeNav(currentNav) {
								this.$navItems.removeClass("active");
								$(currentNav).addClass("active");
						}
						//滚动到可视区

				}, {
						key: 'scrollIntoView',
						value: function scrollIntoView(navIndex) {
								var _this4 = this;

								var offsetTop = parseInt(this.getOffsetTop(navIndex));
								if (!this.$scrollContainer.is(":animated")) {
										this.$scrollContainer.stop().animate({ 'scrollTop': offsetTop }, this.defaults.speed, this.defaults.easing, function () {
												//动画结束后重新注册滚动监听事件
												_this4.spyScroll();
										});
								}
						}
						//获取滚动元素距离顶部的距离

				}, {
						key: 'getOffsetTop',
						value: function getOffsetTop(index) {
								return parseInt($(this.$spyItems[index]).offset().top) - parseInt(this.fixTop);
						}
				}]);

				return jqNavScrollSpy;
		}();

		$.fn.jqNavScrollSpy = function (configs) {
				return this.each(function () {
						if (!$.data(this, "plugin_" + pluginName)) {
								$.data(this, "plugin_" + pluginName, new jqNavScrollSpy(this, configs));
						} else {
								$.data(this, "plugin_" + pluginName, null);
								$.data(this, "plugin_" + pluginName, new jqNavScrollSpy(this, configs));
						}
				});
		};
});